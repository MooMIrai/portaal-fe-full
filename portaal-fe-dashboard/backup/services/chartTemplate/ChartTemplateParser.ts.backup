import React from 'react';
import {
  Chart,
  ChartTitle,
  ChartLegend,
  ChartSeries,
  ChartSeriesItem,
  ChartCategoryAxis,
  ChartCategoryAxisItem,
  ChartValueAxis,
  ChartValueAxisItem,
  ChartTooltip,
  ChartArea
} from '@progress/kendo-react-charts';
import { SafeXMLParser, ParsedNode } from './SafeXMLParser';
import { ComponentRegistry } from './ComponentRegistry';

// Create global component registry
const globalRegistry = new ComponentRegistry();

// Register default Kendo Chart components
globalRegistry.registerComponents({
  Chart,
  ChartTitle,
  ChartLegend,
  ChartSeries,
  ChartSeriesItem,
  ChartCategoryAxis,
  ChartCategoryAxisItem,
  ChartValueAxis,
  ChartValueAxisItem,
  ChartTooltip,
  ChartArea
});

export interface ChartTemplateParserOptions {
  strict?: boolean;
  allowedComponents?: string[];
}

export class ChartTemplateParser {
  private options: ChartTemplateParserOptions;
  private xmlParser: SafeXMLParser;
  private registry: ComponentRegistry;
  
  constructor(options: ChartTemplateParserOptions = {}) {
    this.options = {
      strict: true,
      allowedComponents: [],
      ...options
    };
    this.xmlParser = new SafeXMLParser();
    this.registry = globalRegistry;
  }

  /**
   * Register a custom component
   */
  registerComponent(name: string, component: React.ComponentType<any>): void {
    this.registry.registerComponent(name, component);
  }

  /**
   * Register multiple custom components
   */
  registerComponents(components: Record<string, React.ComponentType<any>>): void {
    this.registry.registerComponents(components);
  }

  /**
   * Parse a chart template string and return React elements
   */
  parse(template: string, data: any[] | any): React.ReactElement {
    try {
      // Debug logging
      console.log('ChartTemplateParser - Template:', template);
      console.log('ChartTemplateParser - Data:', JSON.stringify(data, null, 2));
      
      // Parse the template into a node structure
      const parsedNode = this.xmlParser.parse(template);
      
      // Validate the parsed structure
      this.validateNode(parsedNode);
      
      // Convert to React elements with data
      return this.createReactElement(parsedNode, data);
    } catch (error) {
      console.error('Chart template parsing error:', error);
      throw new Error(`Failed to parse chart template: ${error.message}`);
    }
  }

  /**
   * Validate the parsed node structure
   */
  private validateNode(node: ParsedNode): void {
    if (!this.registry.hasComponent(node.type)) {
      throw new Error(`Component "${node.type}" is not registered. Available components: ${this.registry.getComponentNames().join(', ')}`);
    }

    // Validate children recursively
    if (node.children) {
      node.children.forEach(child => {
        if (typeof child !== 'string') {
          this.validateNode(child);
        }
      });
    }
  }

  /**
   * Create React elements from parsed structure
   */
  private createReactElement(node: ParsedNode, data?: any[]): React.ReactElement {
    const Component = this.registry.getComponent(node.type);
    
    if (!Component) {
      throw new Error(`Component "${node.type}" not found in component registry`);
    }

    // Process props
    const processedProps = this.processProps(node.props, data);
    
    // Add default style to Chart component to ensure it fills container
    if (node.type === 'Chart' && !processedProps.style) {
      processedProps.style = { width: '100%', height: '100%', minHeight: '400px' };
    }

    // Process children
    let children: React.ReactNode = undefined;
    if (node.children && node.children.length > 0) {
      children = node.children.map((child, index) => {
        if (typeof child === 'string') {
          return child;
        }
        return React.cloneElement(
          this.createReactElement(child, data),
          { key: `${child.type}-${index}` }
        );
      });
    }

    // Debug log for ChartSeriesItem
    if (node.type === 'ChartSeriesItem') {
      console.log('ChartSeriesItem props:', processedProps);
      
      // For rangeBar charts, ensure date fields are converted to Date objects
      if (processedProps.type === 'rangeBar' && processedProps.data && processedProps.fromField && processedProps.toField) {
        processedProps.data = processedProps.data.map((item: any) => {
          const newItem = { ...item };
          // Convert date fields to Date objects if they're strings
          if (processedProps.fromField && typeof item[processedProps.fromField] === 'string') {
            newItem[processedProps.fromField] = new Date(item[processedProps.fromField]);
          }
          if (processedProps.toField && typeof item[processedProps.toField] === 'string') {
            newItem[processedProps.toField] = new Date(item[processedProps.toField]);
          }
          return newItem;
        });
        console.log('Converted date fields for rangeBar data:', processedProps.data);
      }
    }

    // For ChartCategoryAxisItem, if we have data, extract categories
    if (node.type === 'ChartCategoryAxisItem' && data && !Array.isArray(data) && data.data) {
      const categories = [...new Set(data.data.map((item: any) => item.taskcategory))];
      if (categories.length > 0 && !processedProps.categories) {
        processedProps.categories = categories;
        console.log('Added categories to ChartCategoryAxisItem:', categories);
      }
    }

    return React.createElement(Component, processedProps, children);
  }

  /**
   * Process props and replace placeholders
   */
  private processProps(props: Record<string, any>, data?: any[] | any): Record<string, any> {
    const processed: Record<string, any> = {};

    Object.entries(props).forEach(([key, value]) => {
      if (value && typeof value === 'object' && value.__placeholder) {
        // Handle dynamic placeholders with case-insensitive matching
        const placeholderName = value.__placeholder;
        
        // If data is an array, use it directly
        if (Array.isArray(data)) {
          processed[key] = data;
        } else if (data && typeof data === 'object') {
          // Find matching key in data object (case-insensitive)
          const dataKeys = Object.keys(data);
          const matchingKey = dataKeys.find(k => 
            k.toLowerCase() === placeholderName.toLowerCase()
          );
          
          if (matchingKey) {
            const foundValue = data[matchingKey];
            
            console.log(`Placeholder "${placeholderName}" matched with key "${matchingKey}", value:`, foundValue);
            
            // If value looks like an ISO date string, convert to Date object
            if (typeof foundValue === 'string' && 
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(foundValue)) {
              processed[key] = new Date(foundValue);
              console.log(`Converted "${foundValue}" to Date object`);
            } else {
              processed[key] = foundValue;
            }
          } else {
            // Placeholder not found in data
            console.warn(`Placeholder "${placeholderName}" not found in data. Available keys:`, Object.keys(data));
            processed[key] = undefined;
          }
        }
      } else if (value && typeof value === 'object' && !Array.isArray(value)) {
        // Recursively process nested objects
        processed[key] = this.processProps(value, data);
      } else {
        // Use value as-is
        processed[key] = value;
      }
    });

    return processed;
  }
}

// Export a singleton instance for convenience
export const chartTemplateParser = new ChartTemplateParser();