import React, { useRef } from 'react';
import { Card, CardBody, CardHeader } from '@progress/kendo-react-layout';
import {
  Chart,
  ChartSeries,
  ChartSeriesItem,
  ChartCategoryAxis,
  ChartCategoryAxisItem,
  ChartLegend,
  ChartTooltip,
  ChartValueAxis,
  ChartValueAxisItem,
} from '@progress/kendo-react-charts';
import { WidgetProps } from '../../types/widget.types';
import { formatParametersDisplay } from '../../utils/parameterFormatters';

export const LineChart: React.FC<WidgetProps> = ({ widget, data, loading, error, currentFilters }) => {
  const chartDataRef = useRef<any[]>([]);
  if (loading) {
    return (
      <Card style={{ width: '100%', height: '100%' }}>
        <CardBody className="flex items-center justify-center">
          <div className="k-loading-indicator k-loading-indicator-large"></div>
        </CardBody>
      </Card>
    );
  }

  if (error) {
    return (
      <Card style={{ width: '100%', height: '100%' }}>
        <CardBody className="flex items-center justify-center text-red-500">
          <div>Errore nel caricamento dei dati</div>
        </CardBody>
      </Card>
    );
  }

  // Check if data is already formatted as series
  const isPreformattedData = data?.data && Array.isArray(data.data) && data.data[0]?.data && Array.isArray(data.data[0].data);
  
  let chartSeries = [];
  let categories = [];
  const config = data?.widget?.config || widget.config || {};
  
  // Store chart data for tooltip access
  chartDataRef.current = [];
  
  if (isPreformattedData) {
    // Data is already formatted as series
    chartSeries = data.data;
    // Store all data items for tooltip access
    chartDataRef.current = chartSeries;
    // Get categories from the first series data items
    if (chartSeries[0]?.data?.length > 0) {
      const categoryField = config.categoryAxis?.field || 'data_formattata';
      categories = chartSeries[0].data.map(item => item.dataItem?.[categoryField] || '');
    }
  } else {
    // Data is a flat array that needs transformation
    const chartData = data?.data || [];
    const categoryField = config.categoryField || config.categoryAxis?.field || 'category';
    categories = chartData.map(item => item[categoryField] || '');
    
    // Get series configuration
    const seriesConfig = config.series || [{ field: 'value', name: 'Valore' }];
    chartSeries = seriesConfig.map(s => ({
      name: s.name,
      color: s.color,
      dashType: s.dashType,
      markers: s.markers,
      data: chartData.map(item => ({ value: item[s.field], dataItem: item }))
    }));
  }
  
  // Axis configurations
  const xAxisConfig = config.xAxis || config.categoryAxis || {};
  const yAxisConfig = config.yAxis || config.valueAxis || {};
  
  // Legend configuration
  const legendConfig = config.legend || { position: 'bottom' };
  
  // Tooltip configuration
  const tooltipConfig = config.tooltip || { visible: true };
  
  // Format parameters for display
  const formattedParameters = formatParametersDisplay(currentFilters, widget.parameters);

  return (
    <Card style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column' }}>
      <CardHeader className="bg-gray-50" style={{ flexShrink: 0, padding: '12px 16px' }}>
        <h3 className="text-lg font-semibold">{widget.name}</h3>
        {formattedParameters && (
          <div className="text-sm text-gray-600 mt-1">{formattedParameters}</div>
        )}
      </CardHeader>
      <CardBody style={{ flex: 1, minHeight: 0, padding: '16px', display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
        <Chart style={{ flex: 1, width: '100%', height: '100%' }}>
            {tooltipConfig.visible && (
            <ChartTooltip 
              render={(props: any) => {
                if (tooltipConfig.template && props.point) {
                  // Find the series by name or index
                  let seriesIndex = 0;
                  for (let i = 0; i < chartDataRef.current.length; i++) {
                    if (chartDataRef.current[i].name === props.point.series.name) {
                      seriesIndex = i;
                      break;
                    }
                  }
                  
                  const dataItem = chartDataRef.current[seriesIndex]?.data[props.point.index]?.dataItem || {};
                  
                  // Replace Kendo template syntax #= ... # with actual values
                  let html = tooltipConfig.template;
                  
                  // Replace all #= expressions #
                  html = html.replace(/#=\s*([^#]+?)\s*#/g, (match, expression) => {
                    // Remove spaces and parse the expression
                    const expr = expression.trim();
                    
                    // Handle simple property access like dataItem.property
                    if (expr.startsWith('dataItem.')) {
                      const property = expr.substring(9); // Remove 'dataItem.'
                      const val = dataItem[property];
                      return val !== undefined && val !== null ? String(val) : '';
                    }
                    
                    // Handle 'value' keyword
                    if (expr === 'value') {
                      return props.point.value !== undefined ? String(props.point.value) : '';
                    }
                    
                    // Handle 'series.name' keyword
                    if (expr === 'series.name') {
                      return props.point.series.name || '';
                    }
                    
                    // Return empty string instead of original match
                    return '';
                  });
                  
                  return <div dangerouslySetInnerHTML={{ __html: html }} />;
                }
                return <div>{props.point?.series?.name}: {props.point?.value}</div>;
              }}
            />
          )}
          
          {legendConfig && <ChartLegend position={legendConfig.position || "bottom"} />}
          
          <ChartCategoryAxis>
            <ChartCategoryAxisItem 
              categories={categories}
              labels={{
                rotation: xAxisConfig.labels?.rotation || xAxisConfig.rotation || 0,
                font: "12px Arial, sans-serif"
              }}
              title={{
                text: xAxisConfig.title?.text || xAxisConfig.label,
                font: "14px Arial, sans-serif"
              }}
            />
          </ChartCategoryAxis>
          
          <ChartValueAxis>
            <ChartValueAxisItem 
              min={yAxisConfig.min}
              max={yAxisConfig.max}
              title={{
                text: yAxisConfig.title?.text || yAxisConfig.label,
                font: "14px Arial, sans-serif"
              }}
              labels={{
                font: "12px Arial, sans-serif"
              }}
              plotBands={yAxisConfig.plotBands}
            />
          </ChartValueAxis>
          
          <ChartSeries>
            {chartSeries.map((s: any, index: number) => (
              <ChartSeriesItem
                key={index}
                type="line"
                data={s.data.map(item => item.value)}
                name={s.name}
                color={s.color}
                markers={{
                  visible: s.markers?.visible !== false,
                  size: s.markers?.size
                }}
                dashType={s.dashType}
              />
            ))}
          </ChartSeries>
        </Chart>
      </CardBody>
    </Card>
  );
};